=== Serial

Communication over serial interfaces is split into serveral parts. On the
lowest level is a UART driver which operates directly on the hardware.

Above that is a library which provides output routines for many types. MµOS
does not implement the typical stdio like facilities or printf like
format strings. This ensures the required flexibility and extensibility which
wouldn't be possible in a standard approach.

One of the most distinct features is the TXQUEUE. This is an additional queue
which uses a tagged binary representation for the data to be transmitted over
serial. This can dramatically reduce the memory footprint for the queue.
For example numbers are represented in the smallest binary form possible,
constant strings can be stored in flash ROM and are only referenced from the
TXQUEUE.


==== Hardware UART

The UART runs asynchronously driven by interrupts. Data is transferred byte by
byte with immediate cyclic buffers. Where supported the transmitter and
receiver can be disabled independently.

Access to the UART is always non-blocking, requests which can't be served
returning or flagging an error.

At startup the receiver is in desynched state and waits for *\r* to appear in
the stream where it changes into the synchronized state and data can be read.
This ensures that only complete lines are returned to the program. Details can
be be configured. In future it will also synchronize when the line is idle.

Pushing a byte to the TX buffer may return an overflow error, the user is
advised to handle this. Checking for free space of this buffer will be
supported later but there will be still a race condition between this check
and the actual push operation. No other errors can happen on the TX side.

Popping a byte from the RX buffer may flag an async error when the buffer is
empty. 'muos_serial_rx_byte ()' will return zero in this case, only then the
error needs to be checked. The receiver has also some more error conditions
which get flagged asynchronously. One has to check for those regularly.

There is also support for registering a function which gets pushed onto the
hpq when there are characters ready for reading. MµOS already comes with a
line editor which can be used in this place.

===== API

PIPADOC:=uart_api

===== configuration

PIPADOC:@uart_config

==== I/O Library

MµOS comes with a library to do formatted text output over serial. This
library does not use printf alike format strings but provides functions for
printing each data type. Actually there are 2 implementations with the same
API but different functionality. The first one pushes data directly to the
transmission buffer while the second one has its own data queue.

NOTE: While the basic variant and the TXQUEUE have the same API, not all
functions are implemented for both variants. This will be fixed in future as
far it makes sense.

.Basic variant

Pushing data directly out makes the code pretty small and the linker will only
link functions which are actually used. The downside is that the TX buffer
needs to hold every byte to be printed. When it overruns an error is reported,
but the output might be truncated. This is suitable for small targets with
little I/O demands, as long one can provide a big enough TX buffer.

.TXQUEUE

Uses a 'tagged' queue as front-end for the TX buffer. Tagged means that the
data can be stored in binary form with some tag about the type in front. The
I/O library then also manages a job on the hpq which does the transfer from
the txqueue to he txbuffer. When the TXQUEUE is in use the TX buffer can be
configured to hold only few bytes.

The implementation ensures that the most compact form will be stored. This can
dramatically reduce the memory footprint for the queue. For example numbers
are represented in the smallest binary form possible, constant strings can be
stored in Flash ROM and are only referenced from the TXQUEUE.

This advantage comes with some weight on the flash side, the TXQUEUE
implementation currently weight over 2k of code, still whenever enough flash
space is available it should be the considered.

Another advantage is that operations on the TXQUEUE are atomic. Data gets
never truncated when the queue is full and an error is returned, either the
whole thing gets pushed or nothing in case of an error. Future plans include
to add some begin/commit transactions support too.

===== API

PIPADOC:@outputfn

===== configuration

PIPADOC:@txqueue_config


==== Lineedit

For building command line interfaces, mµOS comes with a highly configurable
line editor. Over time this is planned to become a complete framework for
controlling the program.

One can enable it by choosing it as callback function of the UART receiver
+MUOS_SERIAL_RXCALLBACK=muos_lineedit+. Then the line editor presents a user
configurable callback which gets called when a line got terminated.

The Line editor can be configure to handle UTF8 encoded text. This only adds
moderate size to the code but causes more serial traffic since editing often
forces a complete line redraw. When UTF8 support is disabled and only 7-bit
ASCII encoding is supported.

Most common line commands are supported. The is cursor moved with cursor keys or
vi keys, other editing keys (Home, End, Backspace, Delete, Overwrite) are
supported.

There is a very simple line recall handler which lets one restore the previous
line when no edits happened yet (Cursor up) or clear the current line (cursor
down). This recall feature is very lightweight and needs only one additional
byte of RAM and little over 100 bytes program space.

===== configuration

PIPADOC:@lineedit_config


