#+TITLE: My micro OS (event scheduler)

this document is WIP!
* Why
  Because we can..

* Development
  The first WIP versions of mµOS are developed for the avr-gcc/avr-libc
  toolchain, with some portability in mind. It is later planned to extend this
  to other platforms like stm32 which *may* require some refinements on the
  API's. General aim is still to stay as simple as the avr toolchain to make
  mirgration for any programmer coming from Atmel programming to Stm32 (and
  perhaps others) as easy as possible. Still we will make no compromises in
  functionality where required.

* Howto
** Configuring
   edit Makefile
** Includes
** Programming
   * dont use 'main()'
   * initialization is in 'void init(void)' by default
     * init runs with interrupts still disabled and clock stopped
     * init() should setup hardware
     * push functions on the queues to do the work
     * interrupts are enabled and timer starts just after init()

** Building

   just 'make'
   other targets


* Concept

** Schedule functioncalls
   mµOS is about events and scheduling functions from different queues.

** Clock
   One hardware timer is used to implement a global clock. Events can be
   scheduled based on this clock. The configuration of this timer (prescaler,
   which hardware timer to be used) is left open to the user.

FIXME what happens when hwclock wraps around but time is read in another
interrupt while global clock counter is not incremented yet? -> add intr
pending bit -> dont read clock in interrupts


*** Adjustments and Skew
    Once started the clock generally only increments.

    PLANNED: when syncronization with the real time is intended one may set it
    once in the initialization routine and later call some apis to adjust it
    slowly, by skipping a beat or increment the counter in small increments
    (the api ensures that not events get lost).

*** Datatypes
    The full time is defined by the global overflow counter and the timers
    internal count register. The global overflow counter can be selected from
    various unsigned integer types (16, 32, 64 bit wide), the internal timer
    counter register extends this value by its size, enabling rather high
    resolution clocks from 24 up to 80 bits precision. Depending on the
    circumstances one should select a proper size so that overflows dont
    happen or don't matter.

    There are following types defined:

    * muos_clock
      Generic type used for modeate long timespans. Depending on configuration
      overflows may occur rarely (or preferably never).

      Also type for the overflow counter.

    * muos_shortclock
      Type for short time intervals. Used in the realtime priority quite for
      events which are scheduled closely.

    * muos_hwclock
      The type of the hardware timer

    * muos_fullclock
      a structure containing the whole clock state with the high bits stored
      as muos_clock and the low bits stored as muos_hwclock. When properly
      configured this state should never overflow for the application runtime.

**** Some math about datatypes and overflows
     |   |    F_CPU |     CLOCK | clock | hwclock | shortclock |  shortclock |   fullclock |      clock |             |
     |   |      MHZ | PRESCALER |  bits |    bits |       bits |        (ms) |     (years) |     (days) | Notes       |
     |---+----------+-----------+-------+---------+------------+-------------+-------------+------------+-------------|
     | # | 0.032768 |      1024 |    32 |       8 |          8 |    8000.000 |      1089.5 |    1553.45 | watch osc   |
     | # |    0.125 |      1024 |    16 |       8 |          8 |    2097.152 |         0.0 |       0.01 | unuseable   |
     | # |   0.0625 |      1024 |    32 |       8 |         16 | 1073741.800 |       571.2 |     814.45 | slow avr    |
     | # |    0.125 |      1024 |    32 |       8 |          8 |    2097.152 |       285.6 |     407.23 | slow avr    |
     | # |        1 |        64 |    32 |       8 |         16 |    4194.304 |         2.2 |       3.18 |             |
     | # |        8 |      1024 |    32 |       8 |         16 |    8388.608 |         4.5 |       6.36 |             |
     | # |       16 |      1024 |    32 |       8 |          8 |      16.384 |         2.2 |       3.18 | 8bit timer  |
     | # |       16 |      1024 |    32 |       8 |         16 |    4194.304 |         2.2 |       3.18 | 8bit timer  |
     | # |       16 |      1024 |    32 |      16 |         16 |    4194.304 |       571.2 |       3.18 | 16bit timer |
     | # |       16 |        64 |    32 |      16 |         16 |     262.144 |        35.7 |       0.20 |             |
     | # |       16 |         1 |    32 |      16 |         16 |       4.096 |         0.6 |       0.00 | fast avr    |
     | # |       72 |       256 |    32 |      16 |         16 |     233.017 |        31.7 |       0.18 | STM32 72MHz |
     | # |      200 |         1 |    64 |      16 |         32 |   21474.836 | 191673930.0 | 1067519.90 | maxed out   |
     #+TBLFM: $7=(2^$6)*$3/($2*1000);%.3f::$8=(2^($4+$5))*$3/($2*1000000)/60/60/24/365;%.1f::$9=(2^($4))*$3/($2*1000000)/60/60/24;%.2f

     Conclusions:
     * less than 32 bit for the clock counter makes hardly any sense, even for
       the slowest configurations it is not enough.
     * more than 32 bit is only needed for fast running clocks or for very
       long uptimes.
     * Choosing 16bit hwclock when it is available will have less interrupt
       load but needs more memory. When in doubt, it is not mandatory.
     * 'clock' alone overflows quite often but using a 64 bit datatype as
       'clock' takes a lot space.
     * use 'fullclock' for ltpq scheduling, 'clock' alone would need another
       sliding window pq implementation with no much benefits.

*** Timer interrupts
    the clock and timer needs 2 interrupts

**** overflow
    increments the global counter, wakes mainloop

**** comparematch
    only wakes mainloop


** Queues
   Functions in Queues running synchronously

*** Priority Queues

**** PLANNED rtpq realtime priority queue
     runs direct in timer interrupt, exact timing, wakes up a little earlier
     spins to exact time.

**** PLANNED ltpq long time queue
     * uses longer, absolute time format (muos_clock or muos_fullclock)
     * needs more memory
     * handled from the clpq (one regular job at each cycles moves elements
       form ltpq to clpq)
     * optional only needed for 'calendar' like events, may be short, only as
       much long time events the program uses at most

**** DONE clpq short time realtime queue
     * uses a sliding window implementation
       more memory conserving, schedules events in near future

***** PLANNED macros for Hz kHz

*** Work Queues
    Most processing should be done by queueing functioncalls into one of the
    following queues. Functions can be pushed onto this queues at the front for
    highest priority (immediate execution) or at the back for fair scheduling.


**** Queue datatypes and sizes
     one can select one of 3 implementations for the queues from which at
     compiletime.

     * one uses 4bit indices on a bitfield (a byte split in half),
       allows for queue size up to 16 entries for very small microcontrollers
       such attinys
     * one uses byte indices, which is the default, allowing queues up to 256
       entries.
     * and one uses uint16_t indices for large queues (up to 64k entries).

     Note that when functioncalls with one intptr_t argument are pushed on a
     queue, it will take 2 entries (one for the functionpointer and one for the argument)

     Queues can be defined to any size within their indexable range and are a
     fixed sized array in RAM.


**** Default Queues

***** DONE Realtime Queue (rtq)
      Will be processed before any bgq events
****** TODO rename to hpq (high priority queue)

***** DONE Background Queue (bgq)
      Is processed in the mainloop when nothing else (rtq) is to do. when the
      bgq (and rtq) is empty, the mainloop goes to sleep waiting for interrupts
      to wake up.


** Interrupts
   Should do only the most minimal work, possibly pushing further events on
   the Work Queues. User define Interrupt handlers may call the rtq processing
   loop at the end.

*** PLANNED Interrupt hooks? adding interrupt handlers dynamically


* Q&A Common Problems
  - lto related problems
    like lto1: fatal error: errors during merging of translation units
    * gives poor error messages
    * saves a *lot* space
  - collect2: error: ld returned 1 exit status
    * Symbol defined multiple times

* Directory Structure
  Only notably files are mentioned

** src
   - Makefile
     sets some configuration variables and includes the
     muos/muos.mk Main Makefile


*** muos
   - muos.c
     the main() loop

   - *.c *.h
     C Source and include files

   - muos.mk
     Main Makefile variable and rules setup for building mµOS, will include all other
     Makefiles.

   - prg_$(PROGRAMMER).mk
     Default variables and rules for programmers

**** lib
     Muos *internal* Library routines used by other facilities.
     Usually don't handle interupt disable/enable unless specifically required.
     Does not check for error conditions for space and performance reasons.
     This must be handled by the caller

**** hw
     All hardware macro and functions have the prefix 'MUOS_HW_' or 'muos_hw_'

     - hwdef.h
       dispatches the including of the actual (most specific) hardware
       definiton file below

***** atmel
      hardware abstractions for atmel chips, organized from most specific chip
      up to generic includes for the respecive platform.

      - platform.mk
        Makefile for building this this platform

      - *.h
        Hardware specific include files,

        - macros to create Hardware specific register names

        - simple 'static inline' functions to operate on this registers

        - abstraction of interupt handling routines

* Planned

** Testing

*** other types for timer (16 bit, different sizes)

** Stack checks

** watchdog
   timeout for rtq, bgq
   how to detect timeouts on clq?

** PLANNED Indirect jump tables for queues
   register all 'callable' functions in one array. The queues can then
   index this table by uint8_t or shorter.

** PLANNED system clock
   osccal calibration on external pulse

** Library

** HAL


** HLD (high level drivers)
*** Serial
**** TX
***** DONE buffered
***** TODO non buffered
***** TODO Tagged queue
      'reserve' some space for coversions
      DOCME txqueue is transactional
**** RX
***** TODO Lineedit
      Selections by config
      block lineedit when TX is stalled
****** DONE simple (backspace only)
****** DONE cursor
****** TODO history
******* simple history, store only 1 byte aside, instant pgup after return restores previous line
****** TODO completion
****** TODO rxsync when line is idle for some frames
******* tab for text
******* pgup/pgdown for values
*** gpio
    configure (in out pullup)
    set, clear, toggle
**** Buttons
**** encoder

*** PWM
*** EEprom
*** Flash
*** Fuses
*** Watchdog

*** USB
*** bangbus
*** onewire
*** DCF77
*** OSCAL
*** CPPM
*** logfs
*** PID++
*** power interface depending on active components
** Debug tools
* Ideas

** Debugger
   over serial
   only few commands, most logic on host side

   * peek
   * 

   * debug() function
   * debug interrupt
   * 
